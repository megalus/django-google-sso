{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#welcome-to-django-google-sso","title":"Welcome to Django Google SSO","text":""},{"location":"#motivation","title":"Motivation","text":"<p>This library aims to simplify the process of authenticating users with Google in Django Admin pages, inspired by libraries like django_microsoft_auth and django-admin-sso</p>"},{"location":"#why-another-library","title":"Why another library?","text":"<ul> <li> <p>This library aims for simplicity and ease of use. django-allauth is   de facto solution for Authentication in Django, but add lots of boilerplate, specially the html templates.   Django-Google-SSO just add a fully customizable \"Login with Google\" button in the default login page.</p> Light ModeDark Mode <p></p> <p></p> </li> <li> <p>django-admin-sso is a good solution, but it uses a deprecated   google <code>auth2client</code> version.</p> </li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install django-google-sso\n</code></pre> <p>Currently this project supports:</p> <ul> <li>Python 3.11, 3.12 and 3.13</li> <li>Django 4.2, 5.0, 5.1 and 5.2</li> </ul> <p>Older python/django versions are not supported.</p>"},{"location":"admin/","title":"Using Django Admin","text":"<p>Django Google SSO integrates with Django Admin, adding an Inline Model Admin to the User model. This way, you can access the Google SSO data for each user.</p>"},{"location":"admin/#using-custom-user-model","title":"Using Custom User model","text":"<p>If you are using a custom user model, you may need to add the <code>GoogleSSOInlineAdmin</code> inline model admin to your custom user model admin, like this:</p> <pre><code># admin.py\n\nfrom django.contrib import admin\nfrom django.contrib.auth.admin import UserAdmin\nfrom django_google_sso.admin import (\n    GoogleSSOInlineAdmin, get_current_user_and_admin\n)\n\nCurrentUserModel, last_admin, LastUserAdmin = get_current_user_and_admin()\n\nif admin.site.is_registered(CurrentUserModel):\n    admin.site.unregister(CurrentUserModel)\n\n\n@admin.register(CurrentUserModel)\nclass CustomUserAdmin(LastUserAdmin):\n    inlines = (\n        tuple(set(list(last_admin.inlines) + [GoogleSSOInlineAdmin]))\n        if last_admin\n        else (GoogleSSOInlineAdmin,)\n    )\n</code></pre> <p>The <code>get_current_user_and_admin</code> helper function will return:</p> <ul> <li>the current registered UserModel in Django Admin (default: <code>django.contrib.auth.models.User</code>)</li> <li>the current registered UserAdmin in Django (default: <code>django.contrib.auth.admin.UserAdmin</code>)</li> <li>the instance of the current registered UserAdmin in Django (default: <code>None</code>)</li> </ul> <p>Use this objects to maintain previous inlines and register your custom user model in Django Admin.</p>"},{"location":"advanced/","title":"Advanced Use","text":"<p>On this section, you will learn how to use Django Google SSO in more advanced scenarios. This section assumes you have a good understanding for Django advanced techniques, like custom User models, custom authentication backends, and so on.</p>"},{"location":"advanced/#using-custom-authentication-backend","title":"Using Custom Authentication Backend","text":"<p>If the users need to log in using a custom authentication backend, you can use the <code>GOOGLE_SSO_AUTHENTICATION_BACKEND</code> setting:</p> <pre><code># settings.py\n\nGOOGLE_SSO_AUTHENTICATION_BACKEND = \"myapp.authentication.MyCustomAuthenticationBackend\"\n</code></pre>"},{"location":"advanced/#using-google-as-single-source-of-truth","title":"Using Google as Single Source of Truth","text":"<p>If you want to use Google as the single source of truth for your users, you can simply set the <code>GOOGLE_SSO_ALWAYS_UPDATE_USER_DATA</code>. This will enforce the basic user data (first name, last name, email and picture) to be updated at every login.</p> <pre><code># settings.py\n\nGOOGLE_SSO_ALWAYS_UPDATE_USER_DATA = True  # Always update user data on login\n</code></pre>"},{"location":"advanced/#adding-additional-data-to-user-model-though-scopes","title":"Adding additional data to User model though scopes","text":"<p>If you need more advanced logic, you can use the <code>GOOGLE_SSO_PRE_LOGIN_CALLBACK</code> setting to import custom data from Google (considering you have configured the right scopes and possibly a Custom User model to store these fields).</p> <p>For example, you can use the following code to update the user's name, email and birthdate at every login:</p> <pre><code># settings.py\n\nGOOGLE_SSO_SAVE_ACCESS_TOKEN = True  # You will need this token\nGOOGLE_SSO_PRE_LOGIN_CALLBACK = \"hooks.pre_login_user\"\nGOOGLE_SSO_SCOPES = [\n    \"openid\",\n    \"https://www.googleapis.com/auth/userinfo.email\",\n    \"https://www.googleapis.com/auth/userinfo.profile\",\n    \"https://www.googleapis.com/auth/user.birthday.read\",  # &lt;- This is a custom scope\n]\n</code></pre> <pre><code># myapp/hooks.py\nimport datetime\nimport httpx\nfrom loguru import logger\n\n\ndef pre_login_user(user, request):\n    token = request.session.get(\"google_sso_access_token\")\n    if token:\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n        }\n\n        # Request Google User Info\n        url = \"https://www.googleapis.com/oauth2/v3/userinfo\"\n        response = httpx.get(url, headers=headers)\n        user_data = response.json()\n        logger.debug(f\"Updating User Data with Google User Info: {user_data}\")\n\n        # Request Google People Info for the additional scopes\n        url = f\"https://people.googleapis.com/v1/people/me?personFields=birthdays\"\n        response = httpx.get(url, headers=headers)\n        people_data = response.json()\n        logger.debug(f\"Updating User Data with Google People Info: {people_data}\")\n        birthdate = datetime.date(**people_data[\"birthdays\"][0]['date'])\n\n        user.first_name = user_data[\"given_name\"]\n        user.last_name = user_data[\"family_name\"]\n        user.email = user_data[\"email\"]\n        user.birthdate = birthdate  # You need a Custom User model to store this field\n        user.save()\n</code></pre>"},{"location":"callback/","title":"Get your Callback URI","text":"<p>The callback URL is the URL where Google will redirect the user after the authentication process. This URL must be registered in your Google project.</p>"},{"location":"callback/#the-callback-uri","title":"The Callback URI","text":"<p>The callback URI is composed of <code>{scheme}://{netloc}/{path}/</code>, where the netloc is the domain name of your Django project, and the path is <code>/google_sso/callback/</code>. For example, if your Django project is hosted on <code>https://myproject.com</code>, then the callback URL will be <code>https://myproject.com/google_sso/callback/</code>.</p> <p>So, let's break each part of this URI:</p>"},{"location":"callback/#the-scheme","title":"The scheme","text":"<p>The scheme is the protocol used to access the URL. It can be <code>http</code> or <code>https</code>. Django-Google-SSO will select the same scheme used by the URL which shows to you the login page.</p> <p>For example, if you're running locally, like <code>http://localhost:8000/accounts/login</code>, then the callback URL scheme will be <code>http://</code>.</p> How about a Reverse-Proxy? <p>If you're running Django behind a reverse-proxy, please make sure you're passing the correct <code>X-Forwarded-Proto</code> header to the login request URL.</p>"},{"location":"callback/#the-netloc","title":"The NetLoc","text":"<p>The NetLoc is the domain of your Django project. It can be a dns name, or an IP address, including the Port, if needed. Some examples are: <code>example.com</code>, <code>localhost:8000</code>, <code>api.my-domain.com</code>, and so on. To find the correct netloc, Django-Google-SSO will check, in that order:</p> <ul> <li>If settings contain the variable <code>GOOGLE_SSO_CALLBACK_DOMAIN</code>, it will use this value.</li> <li>If Sites Framework is active, it will use the domain field for the current site.</li> <li>The netloc found in the URL which shows you the login page.</li> </ul>"},{"location":"callback/#the-path","title":"The Path","text":"<p>The path is the path to the callback view. It will be always <code>/&lt;path in urls.py&gt;/callback/</code>.</p> <p>Remember when you add this to the <code>urls.py</code>?</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"google_sso/\", include(\n            \"django_google_sso.urls\",\n            namespace=\"django_google_sso\"\n        )\n    ),\n]\n</code></pre> <p>The path starts with the <code>google_sso/</code> part. If you change this to <code>sso/</code> for example, your callback URL will change to <code>https://myproject.com/sso/callback/</code>.</p>"},{"location":"callback/#registering-the-uri","title":"Registering the URI","text":"<p>To register the callback URL, in your Google project, add the callback URL in the Authorized redirect URIs field, clicking on button <code>Add URI</code>. Then add your full URL and click on <code>Save</code>.</p> <p>Do not forget the trailing slash</p> <p>Many errors on this step are caused by forgetting the trailing slash:</p> <ul> <li>Good: <code>http://localhost:8000/google_sso/callback/</code></li> <li>Bad: <code>http://localhost:8000/google_sso/callback</code></li> </ul> <p>In the next step, we will configure Django-Google-SSO to auto create the Users.</p>"},{"location":"credentials/","title":"Adding Google Credentials","text":"<p>To make the SSO work, we need to set up, in your Django project, the Google credentials needed to perform the authentication.</p>"},{"location":"credentials/#getting-google-credentials","title":"Getting Google Credentials","text":"<p>In your Google Console navigate to Api -&gt; Credentials to access the credentials for your all Google Cloud Projects.</p> <p>Your first Google Cloud Project</p> <p>If you don't have a Google Cloud Project, you can create one by clicking on the Create button.</p> <p>Then, you can select one of existing Web App Oauth 2.0 Client Ids in your Google project, or create a new one.</p> Do I need to create a new Oauth 2.0 Client Web App? <p>Normally you will have one credential per environment in your Django project. For example, if you have a development, staging and production environments, then you will have three credentials, one for each one. This mitigates the risk of exposing all your data in case of a security breach.</p> <p>If you decide to create a new one, please check https://developers.google.com/identity/protocols/oauth2/ for additional info.</p> <p>When you open your Web App Client Id, please get the following information:</p> <ul> <li>The Client ID. This is something like <code>XXXX.apps.googleusercontent.com</code> and will be the <code>GOOGLE_SSO_CLIENT_ID</code> in   your Django project.</li> <li>The Client Secret Key. This is a long string and will be the <code>GOOGLE_SSO_CLIENT_SECRET</code> in your Django project.</li> <li>The Project ID. This is the Project ID, you can get click on the Project Name, and will be   the <code>GOOGLE_SSO_PROJECT_ID</code> in your Django project.</li> </ul> <p>After that, add them in your <code>settings.py</code> file:</p> <pre><code># settings.py\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"your domain here\"]\nGOOGLE_SSO_CLIENT_ID = \"your client id here\"\nGOOGLE_SSO_CLIENT_SECRET = \"your client secret here\"\nGOOGLE_SSO_PROJECT_ID = \"your project id here\"\n</code></pre> <p>Don't commit this info in your repository. This permits you to have different credentials for each environment and mitigates security breaches. That's why we recommend you to use environment variables to store this info. To read this data, we recommend you to install and use a Twelve-factor compatible library in your project.</p> <p>For example, you can use our sister project Stela to load the environment variables from a <code>.env.local</code> file, like this:</p> <pre><code># .env.local\nGOOGLE_SSO_ALLOWABLE_DOMAINS=[\"your domain here\"]\nGOOGLE_SSO_CLIENT_ID=\"your client id here\"\nGOOGLE_SSO_CLIENT_SECRET=\"your client secret here\"\nGOOGLE_SSO_PROJECT_ID=\"your project id here\"\n</code></pre> <pre><code># Django settings.py\nfrom stela import env\n\nGOOGLE_SSO_ALLOWABLE_DOMAINS = env.GOOGLE_SSO_ALLOWABLE_DOMAINS\nGOOGLE_SSO_CLIENT_ID = env.GOOGLE_SSO_CLIENT_ID\nGOOGLE_SSO_CLIENT_SECRET = env.GOOGLE_SSO_CLIENT_SECRET\nGOOGLE_SSO_PROJECT_ID = env.GOOGLE_SSO_PROJECT_ID\n</code></pre> <p>But in fact, you can use any library you want, like django-environ, django-constance, python-dotenv, etc...</p> <p>In the next step, we need to configure the authorized callback URI for your Django project.</p>"},{"location":"customize/","title":"Customizing the Login Page","text":"<p>Below, you can find some tips on how to customize the login page.</p>"},{"location":"customize/#hiding-the-login-form","title":"Hiding the Login Form","text":"<p>If you want to show only the Google Login button, you can hide the login form using the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> setting.</p> <pre><code># settings.py\n\nSSO_SHOW_FORM_ON_ADMIN_PAGE = False\n</code></pre>"},{"location":"customize/#customizing-the-login-button","title":"Customizing the Login button","text":"<p>Customizing the Login button is very simple. For the logo and text change is straightforward, just inform the new values. For the style, you can override the css file.</p>"},{"location":"customize/#the-button-logo","title":"The button logo","text":"<p>To change the logo, use the <code>GOOGLE_SSO_BUTTON_LOGO</code> setting.</p> <pre><code># settings.py\nGOOGLE_SSO_LOGO_URL = \"https://example.com/logo.png\"\n</code></pre>"},{"location":"customize/#the-button-text","title":"The button text","text":"<p>To change the text, use the <code>GOOGLE_SSO_BUTTON_TEXT</code> setting.</p> <pre><code># settings.py\n\nGOOGLE_SSO_TEXT = \"New login message\"\n</code></pre>"},{"location":"customize/#the-button-style","title":"The button style","text":"<p>The login button css style is located at <code>static/django_google_sso/google_button.css</code>. You can override this file as per Django static files documentation.</p>"},{"location":"customize/#an-example","title":"An example","text":"<pre><code># settings.py\n\nGOOGLE_SSO_TEXT = \"Login using Google Account\"\n</code></pre> <pre><code>/* static/django_google_sso/google_button.css */\n\n/* other css... */\n\n.google-login-btn {\n    background-color: red;\n    border-radius: 3px;\n    padding: 2px;\n    margin-bottom: 10px;\n    width: 100%;\n}\n</code></pre> <p>The result:</p> <p></p>"},{"location":"how/","title":"How Django Google SSO works?","text":""},{"location":"how/#current-flow","title":"Current Flow","text":"<ol> <li> <p>First, the user is redirected to the Django login page. If settings <code>GOOGLE_SSO_ENABLED</code> is True, the \"Login with Google\" button will be added to a default form.</p> </li> <li> <p>On click, Django-Google-SSO will add, in a anonymous request session, the <code>sso_next_url</code> and Google Flow <code>sso_state</code>. This data will expire in 10 minutes (defined in <code>GOOGLE_SSO_TIMEOUT</code>). Then user will be redirected to Google login page.</p> <p>Using Request Anonymous session</p> <p>If you make any actions which change or destroy this session, like restart django, clear cookies or change browsers, ou move between <code>localhost</code> and <code>127.0.0.1</code>, the login will fail, and you can see the message \"State Mismatched. Time expired?\" in the next time you log in again. Also remember the anonymous session lasts for 10 minutes, defined in<code>GOOGLE_SSO_TIMEOUT</code>.</p> </li> <li> <p>On callback, Django-Google-SSO will check <code>code</code> and <code>state</code> received. If they are valid, Google's UserInfo will be retrieved. If the user is already registered in Django, the user will be logged in.</p> </li> <li> <p>Otherwise, the user will be created and logged in, if his email domain, matches one of the <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code>. You can disable the auto-creation setting <code>GOOGLE_SSO_AUTO_CREATE_USERS</code> to False.</p> </li> <li> <p>On creation only, this user can be set to the<code>staff</code> or <code>superuser</code> status, if his email are in <code>GOOGLE_SSO_STAFF_LIST</code> or <code>GOOGLE_SSO_SUPERUSER_LIST</code> respectively. Please note if you add an email to one of these lists, the email domain must be added to <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code>too.</p> </li> <li> <p>This authenticated session will expire in 1 hour, or the time defined, in seconds, in <code>GOOGLE_SSO_SESSION_COOKIE_AGE</code>.</p> </li> <li> <p>If login fails, you will be redirected to route defined in <code>GOOGLE_SSO_LOGIN_FAILED_URL</code> (default: <code>admin:index</code>) which will use Django Messaging system to show the error message.</p> </li> <li> <p>If login succeeds, the user will be redirected to the <code>next_path</code> saved in the anonymous session, or to the route defined in <code>GOOGLE_SSO_NEXT_URL</code> (default: <code>admin:index</code>) as a fallback.</p> </li> </ol>"},{"location":"how/#the-define_sso_providers-template-tag","title":"The <code>define_sso_providers</code> template tag","text":"<p>Django-Google-SSO uses this tag to define which buttons to show on the login page. This is because the same tag is used in other libraries, like django-microsoft-sso and django-github-sso. This tag checks the <code>*_SSO_ENABLED</code>, <code>*_SSO_ADMIN_ENABLED</code> and <code>*_SSO_PAGES_ENABLED</code> settings to return a list of enabled SSO providers for the current request.</p> <p>if you need to customize this, you can pass in the request context the <code>sso_providers</code> variable with a list of providers to show, like this:</p> <pre><code># views.py\nfrom django.shortcuts import render\n\ndef my_view(request):\n    ...\n    sso_providers = [\n        {\n            \"name\": \"Google\",\n            \"logo_url\": \"...\", # URL for the button logo\n            \"text\": \"...\",  # Text for the button\n            \"login_url\": \"...\",  # URL to redirect to start the login flow\n            \"css_url\": \"...\",  # URL for the button CSS\n         }\n    ]\n    return render(request, \"my_login_template.html\", {\"sso_providers\": sso_providers})\n</code></pre> <p>Also, if you're using async views, you can run the original template tags, like this:</p> <pre><code># views.py\nfrom django.shortcuts import render\nfrom django_google_sso.utils import adefine_sso_providers, adefine_show_form\n\nasync def my_async_view(request):\n    ...\n    context = {\n        \"show_admin_form\": await adefine_show_form(request),\n        \"sso_providers\": await adefine_sso_providers(request)\n    }\n    return render(request, \"my_login_template.html\", context)\n</code></pre> <p>The same is valid for define_show_form tag</p> <p>You can pass in the request context the <code>show_admin_form</code> variable with a boolean value to show or hide the default login form.</p>"},{"location":"how/#about-the-google-consent-screen-and-the-authorization-prompt","title":"About the Google consent screen and the authorization prompt","text":"<p>The setting <code>GOOGLE_SSO_AUTHORIZATION_PROMPT</code> controls the <code>prompt</code> parameter sent to Google's OpenID Connect authorization URL. It changes what Google shows to the user during authentication/consent:</p> <ul> <li><code>\"consent\"</code> (default): Always shows the consent screen, even if the user previously granted access to the requested scopes.</li> <li><code>\"select_account\"</code>: Always shows the account chooser so the user can switch Google accounts before continuing.</li> <li><code>\"none\"</code>: Never shows any screen. If the user is not already signed in to Google or has not granted consent yet, Google will return an error instead of showing screens.</li> <li><code>None</code> (or <code>\"\"</code>): Only show the relevant screens when they are needed. If the user is only logged in to one google account and that account has already consented, both the account and consent screens are bypassed. If consent hasn't been given, or the user is signed in to multiple google accounts, the relevant screens are shown. This is the default google prompt behavior.</li> </ul> <p>Notes when testing locally: - If you have already granted consent to the default scopes (<code>openid</code>, <code>userinfo.email</code>, <code>userinfo.profile</code>) for your app, Google may only show the account selection step. This can make it seem like the experience is always the same. - To see the full consent screen again with <code>consent</code>, you can revoke the app permissions from your Google Account (Google Account -&gt; Security -&gt; Third-party access), or change the Scopes to include a new permission. - Using <code>select_account</code> typically results in the \u201cChoose an account\u201d screen, which matches what you are observing locally.</p> <p>Example configuration in your Django settings:</p> <pre><code># Valid values: \"none\", \"consent\", \"select_account\" and None\nGOOGLE_SSO_AUTHORIZATION_PROMPT = None  # default is \"consent\"\n</code></pre> <p>For more details about <code>prompt</code>, see Google's documentation: https://developers.google.com/identity/openid-connect/openid-connect#prompt</p>"},{"location":"model/","title":"Getting Google info","text":""},{"location":"model/#the-user-model","title":"The User model","text":"<p>Django Google SSO saves in the database the following information from Google, using current <code>User</code> model:</p> <ul> <li><code>email</code>: The email address of the user.</li> <li><code>first_name</code>: The first name of the user.</li> <li><code>last_name</code>: The last name of the user.</li> <li><code>username</code>: The email address of the user.</li> <li><code>password</code>: An unusable password, generated using <code>get_unusable_password()</code> from Django.</li> </ul> <p>Getting data on code is straightforward:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n    })\n</code></pre>"},{"location":"model/#the-googlessouser-model","title":"The GoogleSSOUser model","text":"<p>Also, on the <code>GoogleSSOUser</code> model, it saves the following information:</p> <ul> <li><code>picture_url</code>: The URL of the user's profile picture.</li> <li><code>google_id</code>: The Google ID of the user.</li> <li><code>locale</code>: The preferred locale of the user.</li> </ul> <p>This is a one-to-one relationship with the <code>User</code> model, so you can access this data using the <code>googlessouser</code> reverse relation attribute:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n        \"picture\": user.googlessouser.picture_url,\n        \"google_id\": user.googlessouser.google_id,\n        \"locale\": user.googlessouser.locale,\n    })\n</code></pre> <p>You can also import the model directly, like this:</p> <pre><code>from django_google_sso.models import GoogleSSOUser\n\ngoogle_info = GoogleSSOUser.objects.get(user=user)\n</code></pre> <p>You can disable this model</p> <p>If you don't want to save this basic data in the database, you can disable the <code>GoogleSSOUser</code> model by setting the <code>GOOGLE_SSO_SAVE_BASIC_GOOGLE_INFO</code> configuration to <code>False</code> in your <code>settings.py</code> file.</p>"},{"location":"model/#about-google-scopes","title":"About Google Scopes","text":"<p>To retrieve this data Django Google SSO uses the following scopes for Google OAuth 2.0:</p> <pre><code>GOOGLE_SSO_SCOPES = [  # Google default scope\n    \"openid\",\n    \"https://www.googleapis.com/auth/userinfo.email\",\n    \"https://www.googleapis.com/auth/userinfo.profile\",\n]\n</code></pre> <p>You can change this scopes overriding the <code>GOOGLE_SSO_SCOPES</code> setting in your <code>settings.py</code> file. But if you ask the user to authorize more scopes, this plugin will not save this additional data in the database. You will need to implement your own logic to save this data, calling Google again. You can see a example here.</p> <p>The main goal here is simplicity</p> <p>The main goal of this plugin is to be simple to use as possible. But it is important to ask the user once for the scopes. That's why this plugin permits you to change the scopes, but will not save the additional data from it.</p>"},{"location":"model/#the-access-token","title":"The Access Token","text":"<p>To make login possible, Django Google SSO needs to get an access token from Google. This token is used to retrieve User info to get or create the user in the database. If you need this access token, you can get it inside the User Request Session, like this:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n        \"picture\": user.googlessouser.picture_url,\n        \"google_id\": user.googlessouser.google_id,\n        \"locale\": user.googlessouser.locale,\n        \"access_token\": request.session[\"google_sso_access_token\"],\n    })\n</code></pre> <p>Saving the Access Token in User Session is disabled, by default, to avoid security issues. If you need to enable it, you can set the configuration <code>GOOGLE_SSO_SAVE_ACCESS_TOKEN</code> to <code>True</code> in your <code>settings.py</code> file. Please make sure you understand how to secure your cookies before enabling this option.</p>"},{"location":"multiple/","title":"Using Multiple Social Logins","text":"<p>A special advanced case is when you need to log in from multiple social providers. In this case, each provider will have its own package which you need to install and configure. Currently, we support:</p> <ul> <li>Django Google SSO</li> <li>Django Microsoft SSO</li> <li>Django GitHub SSO</li> </ul>"},{"location":"multiple/#install-the-packages","title":"Install the Packages","text":"<p>Install the packages you need:</p> <pre><code>pip install django-google-sso django-microsoft-sso django-github-sso\n\n# Optionally install Stela to handle .env files\npip install stela\n</code></pre>"},{"location":"multiple/#add-package-to-django-project","title":"Add Package to Django Project","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n    # other django apps\n    \"django.contrib.messages\",  # Need for Auth messages\n    \"django_github_sso\",  # Will show as first button in login page\n    \"django_google_sso\",\n    \"django_microsoft_sso\",\n]\n</code></pre> <p>Order matters</p> <p>The first package on list will be the first button in the login page.</p>"},{"location":"multiple/#add-secrets-to-env-file","title":"Add secrets to env file","text":"<pre><code># .env.local\nGOOGLE_SSO_CLIENT_ID=999999999999-xxxxxxxxx.apps.googleusercontent.com\nGOOGLE_SSO_CLIENT_SECRET=xxxxxx\nGOOGLE_SSO_PROJECT_ID=999999999999\n\nMICROSOFT_SSO_APPLICATION_ID=FOO\nMICROSOFT_SSO_CLIENT_SECRET=BAZ\n\nGITHUB_SSO_CLIENT_ID=BAR\nGITHUB_SSO_CLIENT_SECRET=FOOBAR\n</code></pre>"},{"location":"multiple/#setup-django-urls","title":"Setup Django URLs","text":"<p>Add the URLs of each provider to your <code>urls.py</code> file:</p> <pre><code>from django.urls import include, path\n\n\nurlpatterns += [\n    path(\n        \"github_sso/\",\n        include(\"django_google_sso.urls\", namespace=\"django_github_sso\"),\n    ),\n    path(\n        \"google_sso/\",\n        include(\"django_github_sso.urls\", namespace=\"django_google_sso\"),\n    ),\n        path(\n        \"microsoft_sso/\",\n        include(\"django_github_sso.urls\", namespace=\"django_microsoft_sso\"),\n    ),\n]\n</code></pre>"},{"location":"multiple/#setup-django-settings","title":"Setup Django Settings","text":"<p>Add the settings of each provider to your <code>settings.py</code> file:</p> <pre><code># settings.py\nfrom stela import env\n\n# Django Microsoft SSO\nMICROSOFT_SSO_ENABLED = True\nMICROSOFT_SSO_APPLICATION_ID = env.MICROSOFT_SSO_APPLICATION_ID\nMICROSOFT_SSO_CLIENT_SECRET = env.MICROSOFT_SSO_CLIENT_SECRET\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = [\"contoso.com\"]\n\n# Django Google SSO\nGOOGLE_SSO_ENABLED = True\nGOOGLE_SSO_CLIENT_ID = env.GOOGLE_SSO_CLIENT_ID\nGOOGLE_SSO_PROJECT_ID = env.GOOGLE_SSO_PROJECT_ID\nGOOGLE_SSO_CLIENT_SECRET = env.GOOGLE_SSO_CLIENT_SECRET\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"contoso.net\"]\n\n# Django GitHub SSO\nGITHUB_SSO_ENABLED = True\nGITHUB_SSO_CLIENT_ID = env.GITHUB_SSO_CLIENT_ID\nGITHUB_SSO_CLIENT_SECRET = env.GITHUB_SSO_CLIENT_SECRET\nGITHUB_SSO_ALLOWABLE_ORGANIZATIONS = [\"contoso\"]\n</code></pre> <p>The login page will look like this:</p> <p></p> <p>You can hide the login form</p> <p>If you want to show only the SSO buttons, you can hide the login form using the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> setting.</p> <pre><code># settings.py\n\nSSO_SHOW_FORM_ON_ADMIN_PAGE = False\n</code></pre>"},{"location":"multiple/#avoiding-duplicated-users","title":"Avoiding duplicated Users","text":"<p>Both Django GitHub SSO and Django Microsoft SSO can create users without an email address, comparing the User <code>username</code> field against the Azure User Principal Name or Github User Name. This can cause duplicated users if you are using either package.</p> <p>To avoid this, you can set the <code>MICROSOFT_SSO_UNIQUE_EMAIL</code> and <code>GITHUB_SSO_UNIQUE_EMAIL</code> settings to <code>True</code>, making these packages compare User <code>email</code> against Azure Mail field or Github Primary Email. Make sure your Azure Tenant and GitHub Organization users have registered emails.</p>"},{"location":"multiple/#the-django-e003w003-warning","title":"The Django E003/W003 Warning","text":"<p>If you are using multiple Django SSO projects, you will get a warning like this:</p> <pre><code>WARNINGS:\n?: (templates.E003) 'show_form' is used for multiple template tag modules: 'django_google_sso.templatetags.show_form', 'django_microsoft_sso.templatetags.show_form'\n?: (templates.E003) 'sso_tags' is used for multiple template tag modules: 'django_google_sso.templatetags.sso_tags', 'django_microsoft_sso.templatetags.sso_tags'\n</code></pre> <p>This is because both packages use the same template tags. To silence this warning, you can set the <code>SILENCED_SYSTEM_CHECKS</code> as per Django documentation:</p> <pre><code># settings.py\nSILENCED_SYSTEM_CHECKS = [\"templates.W003\"] # Or \"templates.E003\" for Django &lt;=5.0\n</code></pre> <p>But if you need to check the templates, you can use the <code>SSO_USE_ALTERNATE_W003</code> setting to use an alternate template tag. This alternate check will run the original check, but will not raise the warning for the Django SSO packages. To use this alternate check, you need to set both the Django Silence Check and <code>SSO_USE_ALTERNATE_W003</code>:</p> <pre><code># settings.py\n\nSILENCED_SYSTEM_CHECKS = [\"templates.W003\"]  # Will silence the original check\nSSO_USE_ALTERNATE_W003 = True  # Will run alternate check\n</code></pre> <p>The tags will be executed only once, per request, for the last installed package</p> <p>To avoid multiple executions for the <code>define_sso_providers</code> and <code>define_show_form</code> tags, these code will be executed once and the result will be cached on the request object. Due to django template loading mechanism, the tag's code from the last installed package will be the one executed. This means if you have multiple packages installed, only the last one will be executed. To avoid this, you can use the <code>sso_providers</code> and <code>show_admin_form</code> context variables to pass the values you want to show in the template.</p> <pre><code># views.py\nfrom django.shortcuts import render\nfrom django_google_sso.template_tags import define_sso_providers, define_show_form\n\ndef my_login_view(request):\n    ...\n    sso_providers = define_sso_providers({\"context\": request})\n    show_admin_form = define_show_form({\"context\": request})\n\n    return render(\n        request,\n        \"my_login_template.html\",\n        {\"sso_providers\": sso_providers, \"show_admin_form\": show_admin_form},\n    )\n</code></pre>"},{"location":"multiple/#split-providers-between-admin-and-page-logins","title":"Split Providers between Admin and Page Logins","text":"<p>If you want to use different providers for Admin and Page logins, you may need to enable/disable providers per request. For example, suppose if you want to use all Django SSOs for Page login but only Django Google SSO for the Admin, you can add the respective <code>*_SSO_PAGES_ENABLED</code> and <code>*_SSO_ADMIN_ENABLED</code>, like this:</p> <pre><code># settings.py\n\n# Enable or Disable globally (both Admin and Pages):\nGOOGLE_SSO_ENABLED = True\nMICROSOFT_SSO_ENABLED = True\nGITHUB_SSO_ENABLED = True\n\n# Enable or disable per request path:\nMICROSOFT_SSO_ADMIN_ENABLED = False\nMICROSOFT_SSO_PAGES_ENABLED = True\nGITHUB_SSO_ADMIN_ENABLED = False\nGITHUB_SSO_PAGES_ENABLED = True\n</code></pre> <p>You need to be explicit on these settings</p> <p>If you set <code>GOOGLE_SSO_ADMIN_ENABLED = False</code> and do not set <code>GOOGLE_SSO_PAGES_ENABLED</code>, the default value for <code>GOOGLE_SSO_PAGES_ENABLED</code> is also <code>False</code>. This means Google SSO will be disabled for both Admin and Page logins. You need to be explicit on these settings.</p>"},{"location":"pages/","title":"Using Django Google SSO outside Django Admin","text":"<p>Django-Google-SSO aims for simplicity, that's why the primary focus is on the Admin login logic. But this package can be used outside Django Admin, in a custom login page. To do so, you can follow the steps below.</p> <p>This is the Tip of the Iceberg</p> <p>In real-life projects, user customer login involves more than just a login button. You need to implement many features like OTP, Captcha, \"Recover Password\", \"Remember Me\", \"Login with Passkey\" etc. This documentation shows a simple implementation to demonstrate how to use Django Google SSO outside Django Admin, but for more complex UX requisites, please check full solutions like django-allauth, or incremental solutions like django-otp, django-recaptcha, django-passkeys, etc.</p>"},{"location":"pages/#add-django-google-sso-templates-to-your-login-page","title":"Add Django Google SSO templates to your login page","text":"<p>Inside your login template, just add these two lines:</p> <ul> <li><code>{% include 'google_sso/login_sso.html' %}</code> inside <code>&lt;body&gt;</code></li> <li><code>{% static 'django_google_sso/google_button.css' %}</code> inside <code>&lt;head&gt;</code></li> </ul>"},{"location":"pages/#login-template-example","title":"Login template example","text":"<pre><code>{% load static %}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Page Login&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"{% static 'django_google_sso/google_button.css' %}\"&gt;\n        &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css\" rel=\"stylesheet\"\n              integrity=\"sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7\" crossorigin=\"anonymous\"&gt;\n        &lt;style&gt;\n            body {\n                background-color: #f8f9fa;\n            }\n            .microsoft-login-btn, .google-login-btn, .github-login-btn {\n                padding: 6px 4px;\n                height: 36px;\n            }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body class=\"container d-flex flex-column vh-100\"&gt;\n        &lt;div class=\"d-flex flex-column w-100\"&gt;\n            {% if messages %}\n                {% for message in messages %}\n                    &lt;div class=\"alert\n                                {% if message.tags == 'error' %}alert-danger{% else %}alert-{{ message.tags }}{% endif %}\" role=\"alert\"&gt;\n                        {{ message }}\n                    &lt;/div&gt;\n                {% endfor %}\n            {% endif %}\n        &lt;/div&gt;\n        &lt;div class=\"d-flex flex-column justify-content-center align-items-center flex-grow-1\"&gt;\n            &lt;div class=\"card p-4 d-flex align-items-center\" style=\"width: 22rem;\"&gt;\n                &lt;div class=\"h4\"&gt;Django Google SSO&lt;/div&gt;\n                {% include 'google_sso/login_sso.html' %}\n                &lt;a href=\"{% url 'admin:index' %}\" class=\"mt-2\"&gt;Go to Admin&lt;/a&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The <code>include</code> command will add the login button to your template for all django-sso installed in the project.</p>"},{"location":"pages/#define-per-request-parameters","title":"Define per-request parameters","text":"<p>In the case you need different behavior for the login to Admin and login to Django pages, you can define this using callables on the Django Google SSO settings. For example:</p> Setting Login to Admin Login to Pages <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code> <code>[\"example.com\"]</code> <code>[\"*\"]</code> <code>GOOGLE_SSO_LOGIN_FAILED_URL</code> <code>\"admin:login\"</code> <code>\"index\"</code> <code>GOOGLE_SSO_NEXT_URL</code> <code>\"admin:index\"</code> <code>\"secret\"</code> <code>GOOGLE_SSO_SESSION_COOKIE_AGE</code> <code>3600</code> <code>86400</code> <code>GOOGLE_SSO_STAFF_LIST</code> <code>[...]</code> <code>[]</code> <code>GOOGLE_SSO_SUPERUSER_LIST</code> <code>[...]</code> <code>[]</code> <p>You can config almost all settings per request</p> <p>You can config different Google credentials, Scopes, Default Locale, etc. Please check the Settings and Sites docs for more details.</p>"},{"location":"pages/#settings-logic-example","title":"Settings logic example","text":"<pre><code># settings.py\nfrom django_google_sso.helpers import is_admin_path\n\n\ndef get_sso_config(request):\n    config = {\n        \"admin\": {\n            \"allowable_domains\": env.get_or_default(\"GOOGLE_SSO_ALLOWABLE_DOMAINS\", []),\n            \"login_failed_url\": \"admin:login\",\n            \"next_url\": \"admin:index\",\n            \"session_cookie_age\": 3600,  # 1 hour - default\n            \"staff_list\": env.get_or_default(\"GOOGLE_SSO_STAFF_LIST\", []),\n            \"superuser_list\": env.get_or_default(\"GOOGLE_SSO_SUPERUSER_LIST\", []),\n            \"auto_create_first_superuser\": True,  # Create superuser on first eligible user login\n        },\n        \"pages\": {\n            \"allowable_domains\": [\"*\"],  # Allow all domains\n            \"login_failed_url\": \"index\",\n            \"next_url\": \"secret\",\n            \"session_cookie_age\": 86400,  # 24 hours\n            \"staff_list\": [],\n            \"superuser_list\": [],\n            \"auto_create_first_superuser\": False,\n        },\n    }\n    if is_admin_path(request):\n        logger.debug(\"Returning Admin SSO configuration\")\n        return config[\"admin\"]\n    else:\n        logger.debug(\"Returning Pages SSO configuration\")\n        return config[\"pages\"]\n\n\n# Configure settings as callables\nGOOGLE_SSO_ALLOWABLE_DOMAINS = lambda request: get_sso_config(request)[\n    \"allowable_domains\"\n]\nGOOGLE_SSO_LOGIN_FAILED_URL = lambda request: get_sso_config(request)[\n    \"login_failed_url\"\n]\nGOOGLE_SSO_NEXT_URL = lambda request: get_sso_config(request)[\"next_url\"]\nGOOGLE_SSO_SESSION_COOKIE_AGE = lambda request: get_sso_config(request)[\n    \"session_cookie_age\"\n]\nGOOGLE_SSO_STAFF_LIST = lambda request: get_sso_config(request)[\"staff_list\"]\nGOOGLE_SSO_SUPERUSER_LIST = lambda request: get_sso_config(request)[\"superuser_list\"]\nGOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER = lambda request: get_sso_config(request)[\n    \"auto_create_first_superuser\"\n]\n</code></pre>"},{"location":"pages/#toggle-google-sso-between-admin-and-page-logins","title":"Toggle Google SSO between Admin and Page logins","text":"<p>Finally, if you want to toggle between Admin and Page login, you can enable/disable Google SSO using the <code>GOOGLE_SSO_PAGES_ENABLED</code> and <code>GOOGLE_SSO_ADMIN_ENABLED</code>. For example, if you want to enable Google SSO only for Page login:</p> <pre><code># settings.py\n\n# Enable or disable globally\nGOOGLE_SSO_ENABLED = True\n\n# Enable or Disable per request\n# Always configure both Admin and Pages settings\nGOOGLE_SSO_ADMIN_ENABLED = False\nGOOGLE_SSO_PAGES_ENABLED = True\n</code></pre> <p>How Package knows if the request is for Admin or Page login?</p> <p>The package uses the <code>is_admin_path</code> and <code>is_page_path</code> helpers to check if the <code>request.path</code> starts with the admin path. To find the admin path, the package uses the <code>SSO_ADMIN_ROUTE</code> setting (default: <code>admin:index</code>).</p> <pre><code># settings.py\nfrom django_google_sso.helpers import is_admin_path, is_page_path\n\nSSO_ADMIN_ROUTE = \"admin:index\"  # Default admin route\n\nGOOGLE_SSO_ENABLED = True\nGOOGLE_SSO_ADMIN_ENABLED = is_admin_path  # Same as True\nGOOGLE_SSO_PAGES_ENABLED = is_page_path  # Same as True\n</code></pre>"},{"location":"quick_setup/","title":"Quick Setup","text":""},{"location":"quick_setup/#setup-django-settings","title":"Setup Django Settings","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n    # other django apps\n    \"django.contrib.messages\",  # Need for Auth messages\n    \"django_google_sso\",  # Add django_google_sso\n]\n</code></pre>"},{"location":"quick_setup/#setup-google-credentials","title":"Setup Google Credentials","text":"<p>Now, add your Google Project Web App API Credentials in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nGOOGLE_SSO_CLIENT_ID = \"your Web App Client Id here\"\nGOOGLE_SSO_CLIENT_SECRET = \"your Web App Client Secret here\"\nGOOGLE_SSO_PROJECT_ID = \"your Google Project Id here\"\n</code></pre>"},{"location":"quick_setup/#setup-callback-uri","title":"Setup Callback URI","text":"<p>In Google Console at Api -&gt; Credentials -&gt; Oauth2 Client, add the following Authorized Redirect URI: <code>https://your-domain.com/google_sso/callback/</code> replacing <code>your-domain.com</code> with your real domain (and Port). For example, if you're running locally, you can use <code>http://localhost:8000/google_sso/callback/</code>.</p> <p>Do not forget the trailing slash!</p>"},{"location":"quick_setup/#setup-auto-create-users","title":"Setup Auto-Create Users","text":"<p>The next option is to set up the auto-create users from Django Google SSO. Only emails with the allowed domains will be created automatically. If the email is not in the allowed domains, the user will be redirected to the login page.</p> <pre><code># settings.py\n\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"your-domain.com\"]\n</code></pre>"},{"location":"quick_setup/#setup-django-urls","title":"Setup Django URLs","text":"<p>And in your <code>urls.py</code> please add the Django-Google-SSO views:</p> <pre><code># urls.py\n\nfrom django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"google_sso/\", include(\n            \"django_google_sso.urls\",\n            namespace=\"django_google_sso\"\n        )\n    ),\n]\n</code></pre>"},{"location":"quick_setup/#run-django-migrations","title":"Run Django migrations","text":"<p>Finally, run migrations</p> <pre><code>$ python manage.py migrate\n</code></pre> <p>And, that's it: Django Google SSO is ready for use. When you open the admin page, you will see the \"Login with Google\" button:</p> Light ModeDark Mode <p></p> <p></p> How about Django Admin skins, like Grappelli? <p>Django Google SSO will works with any Django Admin skin which calls the original Django login template, like Grappelli, Django Jazzmin, Django Admin Interface and Django Jet Reboot.</p> <p>If the skin uses his own login template, you will need create your own <code>admin/login.html</code> template to add both HTML from custom login.html from the custom package and from this library.</p> <p>For the next pages, let's see each one of these steps with more details.</p>"},{"location":"settings/","title":"All Django Settings options","text":"Setting Description <code>GOOGLE_SSO_ADMIN_ENABLED</code> Enable SSO only when allowed on Admin pages. Default: <code>None</code> <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code> List of domains that will be allowed to create users. Default: <code>[]</code> <code>GOOGLE_SSO_ALWAYS_UPDATE_USER_DATA</code> If true, update default user info from Google data at every login. This will also make their password unusable. Otherwise, all of this happens only on create. Default: <code>False</code> <code>GOOGLE_SSO_AUTHENTICATION_BACKEND</code> The authentication backend to use.  Default: <code>None</code> <code>GOOGLE_SSO_AUTHORIZATION_PROMPT</code> The \"prompt\" value to pass to the Google authorization URL (see https://developers.google.com/identity/openid-connect/openid-connect#prompt). Default: <code>consent</code> <code>GOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER</code> If True, the first user that logs in will be created as superuser if no superuser exists in the database at all. Default: <code>False</code> <code>GOOGLE_SSO_AUTO_CREATE_USERS</code> Enable or disable the auto-create users feature. Default: <code>True</code> <code>GOOGLE_SSO_CALLBACK_DOMAIN</code> The netloc to be used on Callback URI. Default: <code>None</code> <code>GOOGLE_SSO_CLIENT_ID</code> The Google OAuth 2.0 Web Application Client ID. Default: <code>None</code> <code>GOOGLE_SSO_CLIENT_SECRET</code> The Google OAuth 2.0 Web Application Client Secret. Default: <code>None</code> <code>GOOGLE_SSO_DEFAULT_LOCALE</code> Default code for Google locale. Default: <code>en</code> <code>GOOGLE_SSO_ENABLE_LOGS</code> Show Logs from the library. Default: <code>True</code> <code>GOOGLE_SSO_ENABLE_MESSAGES</code> Show Messages using Django Messages Framework. Default: <code>True</code> <code>GOOGLE_SSO_ENABLED</code> Enable or disable the plugin. Default: <code>True</code> <code>GOOGLE_SSO_LOGIN_FAILED_URL</code> The named url path that the user will be redirected to if an authentication error is encountered. Default: <code>admin:index</code> <code>GOOGLE_SSO_LOGO_URL</code> The URL of the logo to be used on the login button. Default: <code>https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Google_%22G%22_logo.svg/1280px-Google_%22G%22_logo.svg.png</code> <code>GOOGLE_SSO_NEXT_URL</code> The named url path that the user will be redirected if there is no next url after successful authentication. Default: <code>admin:index</code> <code>GOOGLE_SSO_PAGES_ENABLED</code> Enable SSO button injection on non-admin pages. Default: <code>None</code> <code>GOOGLE_SSO_PRE_CREATE_CALLBACK</code> Callable for processing pre-create logic. Default: <code>django_google_sso.hooks.pre_create_user</code> <code>GOOGLE_SSO_PRE_LOGIN_CALLBACK</code> Callable for processing pre-login logic. Default: <code>django_google_sso.hooks.pre_login_user</code> <code>GOOGLE_SSO_PRE_VALIDATE_CALLBACK</code> Callable for processing pre-validate logic. Default: <code>django_google_sso.hooks.pre_validate_user</code> <code>GOOGLE_SSO_PROJECT_ID</code> The Google OAuth 2.0 Project ID. Default: <code>None</code> <code>GOOGLE_SSO_SAVE_ACCESS_TOKEN</code> Save the access token in the session. Default: <code>False</code> <code>GOOGLE_SSO_SAVE_BASIC_GOOGLE_INFO</code> Save basic Google info in the database. Default: <code>True</code> <code>GOOGLE_SSO_SCOPES</code> The Google OAuth 2.0 Scopes. Default: <code>[\"openid\", \"https://www.googleapis.com/auth/userinfo.email\", \"https://www.googleapis.com/auth/userinfo.profile\"]</code> <code>GOOGLE_SSO_SESSION_COOKIE_AGE</code> The age of the session cookie in seconds. Default: <code>3600</code> <code>GOOGLE_SSO_SHOW_FAILED_LOGIN_MESSAGE</code> Show a message on browser when the user creation fails on database. Default: <code>False</code> <code>GOOGLE_SSO_STAFF_LIST</code> List of emails that will be created as staff. Default: <code>[]</code> <code>GOOGLE_SSO_SUPERUSER_LIST</code> List of emails that will be created as superuser. Default: <code>[]</code> <code>GOOGLE_SSO_TEXT</code> The text to be used on the login button. Default: <code>Sign in with Google</code> <code>GOOGLE_SSO_TIMEOUT</code> The timeout for the Google SSO authentication returns info, in minutes. Default: <code>10</code> <code>SSO_ADMIN_ROUTE</code> The admin index page route. Default: <code>admin:index</code> <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> Show the form on the admin page. Default: <code>True</code> <code>SSO_USE_ALTERNATE_W003</code> Use alternate W003 warning. You need to silence original templates.W003 warning. Default: <code>False</code>"},{"location":"sites/","title":"Using Django Sites Framework","text":"<p>Django Google SSO supports the Django Sites Framework, allowing you to have different SSO configurations for different sites in your Django project.</p>"},{"location":"sites/#how-it-works","title":"How It Works","text":"<p>Most configuration settings in Django Google SSO can now accept either a direct value or a callable function that receives the current request and returns the appropriate value for the current site.</p> <p>This means you can dynamically determine configuration values based on the current site being accessed, enabling scenarios like:</p> <ul> <li>Different Google OAuth credentials per site</li> <li>Different user creation policies per site</li> <li>Different session timeouts per site</li> </ul>"},{"location":"sites/#setup","title":"Setup","text":"<ol> <li>First, ensure the Django Sites Framework is properly configured in your project:</li> </ol> <pre><code># settings.py\nINSTALLED_APPS = [\n    # ...\n    'django.contrib.sites',\n    'django_google_sso',\n    # ...\n]\n\nSITE_ID = 1  # Default site ID\n</code></pre> <ol> <li> <p>Create your sites in the Django admin or via migrations.</p> </li> <li> <p>Configure Django Google SSO settings as callables that return different values based on the current site:</p> </li> </ol> <pre><code># settings.py\nfrom django.contrib.sites.shortcuts import get_current_site\n\ndef get_client_id(request):\n    \"\"\"Return different client ID based on the current site.\"\"\"\n    site = get_current_site(request)\n\n    # Map site domains to client IDs\n    client_ids = {\n        'example.com': 'client-id-for-example-com',\n        'other-site.com': 'client-id-for-other-site',\n    }\n\n    return client_ids.get(site.domain, 'default-client-id')\n\n# Configure settings as callables\nGOOGLE_SSO_CLIENT_ID = get_client_id\n</code></pre>"},{"location":"sites/#example-complete-site-specific-configuration","title":"Example: Complete Site-Specific Configuration","text":"<p>Here's a more comprehensive example showing how to configure multiple settings per site:</p> <pre><code># settings.py\nfrom django.contrib.sites.shortcuts import get_current_site\n\ndef get_site_config(request, config_key):\n    \"\"\"Get site-specific configuration.\"\"\"\n    site = get_current_site(request)\n\n    # Define configurations for each site\n    site_configs = {\n        'example.com': {\n            'client_id': 'client-id-for-example-com',\n            'client_secret': 'secret-for-example-com',\n            'project_id': 'project-id-for-example-com',\n            'auto_create_users': True,\n            'session_cookie_age': 3600,  # 1 hour\n            'allowable_domains': ['example.com', 'example.org'],\n        },\n        'other-site.com': {\n            'client_id': 'client-id-for-other-site',\n            'client_secret': 'secret-for-other-site',\n            'project_id': 'project-id-for-other-site',\n            'auto_create_users': False,\n            'session_cookie_age': 86400,  # 24 hours\n            'allowable_domains': ['other-site.com'],\n        }\n    }\n\n    # Get config for current site, or use defaults\n    site_config = site_configs.get(site.domain, {})\n    return site_config.get(config_key, None)\n\n# Configure settings as callables\nGOOGLE_SSO_CLIENT_ID = lambda request: get_site_config(request, 'client_id')\nGOOGLE_SSO_CLIENT_SECRET = lambda request: get_site_config(request, 'client_secret')\nGOOGLE_SSO_PROJECT_ID = lambda request: get_site_config(request, 'project_id')\nGOOGLE_SSO_AUTO_CREATE_USERS = lambda request: get_site_config(request, 'auto_create_users')\nGOOGLE_SSO_SESSION_COOKIE_AGE = lambda request: get_site_config(request, 'session_cookie_age')\nGOOGLE_SSO_ALLOWABLE_DOMAINS = lambda request: get_site_config(request, 'allowable_domains')\n</code></pre> <p>Unsupported Settings for Callables</p> <p>All settings support callable configuration, except the following:</p> <ul> <li><code>GOOGLE_SSO_ENABLED</code></li> <li><code>GOOGLE_SSO_ENABLE_LOGS</code></li> <li><code>SSO_USE_ALTERNATE_W003</code></li> </ul>"},{"location":"thanks/","title":"Thank you","text":"<p>Thank you for using this project. And for all the appreciation, patience and support.</p> <p>I really hope this project can make your life a little easier.</p> <p>Please feel free to check our other projects:</p> <ul> <li>stela: Easily manage project settings and secrets in any python project.</li> <li>django-google-sso: A Django app to enable Single Sign-On with Google Accounts.</li> <li>django-microsoft-sso: A Django app to enable Single Sign-On with Microsoft 365 Accounts.</li> <li>django-github-sso: A Django app to enable Single Sign-On with GitHub Accounts.</li> </ul>"},{"location":"thanks/#donating","title":"Donating","text":"<p>If you like to finance this project, please consider donating:</p> <p></p>"},{"location":"third_party_admins/","title":"Using Third Party Django Admins","text":"<p>Django has a great ecosystem, and many third-party apps are available to completely replace the default UI for Django Admin. We are trying to make Django Google SSO compatible as much as possible with these third-party apps. We can divide these apps broadly into two categories: apps which use the original Django Admin login template and apps with custom login templates.</p> How can I know if the third app has a custom login template? <p>Check if the app code contains the <code>templates/admin/login.html</code> file. If the file exists, the app has a custom login template.</p>"},{"location":"third_party_admins/#apps-with-use-original-django-admin-login-template","title":"Apps with use original Django Admin login template","text":"<p>For these apps, Django Google SSO will work out of the box. You don't need to do anything special to make it work.</p> <p>Some examples:</p> <ul> <li>Django Admin Interface</li> <li>Django Grappelli</li> <li>Django Jazzmin</li> <li>Django Jet Reboot</li> </ul>"},{"location":"third_party_admins/#apps-with-custom-login-template","title":"Apps with custom login template","text":"<p>For these apps, you will need to create your own <code>admin/login.html</code> template to add both HTML from the custom login.html from the custom package and from this library, using this basic guideline:</p>"},{"location":"third_party_admins/#create-a-custom-templatesadminloginhtml-template","title":"Create a custom <code>templates/admin/login.html</code> template","text":"<p>Suppose the <code>templates/admin/login.html</code> from the 3<sup>rd</sup> party app is using this structure:</p> <pre><code>{% extends \"third_app/base.html\" %}\n\n{% block my_form %}\n    &lt;form method=\"post\" action=\"{% url 'admin:login' %}\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;input type=\"submit\" value=\"Log in\"&gt;\n{% endblock %}\n</code></pre> <p>Please add on your project the <code>templates/admin/login.html</code> template:</p> <pre><code>{% extends \"admin/login.html\" %}\n\n{% block my_form %} {# Use the name of the block from the third-party app #}\n    {{ block.super }} {# this will include the 3rd party app login.html content #}\n    {% include \"google_sso/login_sso.html\" %} {# this will include the Google SSO login button #}\n{% endblock %}\n</code></pre> <p>Now, let's add support to the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> option. To do this, update the code to include our <code>show_form</code> tag:</p> <pre><code>{% extends \"admin/login.html\" %}\n{% load show_form %}\n\n{% block my_form %} {# Use the name of the block from the third-party app #}\n    {% define_show_form as show_form %}\n        {% if show_form %}\n            {{ block.super }} {# this will include the 3rd party app login.html content #}\n        {% endif %}\n    {% include \"google_sso/login_sso.html\" %} {# this will include the Google SSO login button #}\n{% endblock %}\n</code></pre> <p>This is a basic example.</p> <p>In real cases, you will need to understand how to find the correct elements to hide, and/or how to correct positioning the SSO buttons on the 3<sup>rd</sup> party app layout. Use the real life example from <code>django-unfold</code> described below.</p> <p>Also, make sure you understand how Django works with Template inheritance and How to override templates.</p>"},{"location":"third_party_admins/#current-custom-login-apps-support","title":"Current Custom Login Apps support","text":"<p>To this date, Django Google SSO provides support out of the box for these apps with custom login templates:</p> <ul> <li>Django Unfold</li> </ul> <p>For the Django Unfold this is the code used on our login template:</p> <pre><code>{% extends \"admin/login.html\" %}\n{% load static %}\n{% load sso_tags %}\n{% load show_form %}\n{% load i18n %}\n\n{% block extrastyle %}\n    {{ block.super }}\n    {% with sso_providers|default:None as sso_providers %}\n        {% if sso_providers is None %}\n            {% define_sso_providers as sso_providers %}\n        {% endif %}\n        {% for provider in sso_providers %}\n            &lt;link rel=\"stylesheet\" href=\"{{ provider.css_url }}\"&gt;\n        {% endfor %}\n    {% endwith %}\n{% endblock %}\n\n{# Default Django Admin Block #}\n{% block content %}\n    &lt;!--\n        You can pass a custom Show Form to this\n        template using the `show_admin_form` context variable.\n        If not provided, the template will use the default\n        `define_show_form` defined in the sso tags.\n    --&gt;\n    {% with show_admin_form|default:None as show_form %}\n        {% if show_form is None %}\n            {% define_show_form as show_form %}\n        {% endif %}\n        {% if show_form %}\n            {{ block.super }}\n        {% endif %}\n        {% include 'google_sso/login_sso.html' %}\n    {% endwith %}\n{% endblock %}\n\n{# Django Unfold Admin Block #}\n{% block base %}\n    {{ block.super }}  {# Process HTML login elements from Django Unfold #}\n    {% include 'google_sso/login_sso.html' %} {# Add Google SSO HTML elements #}\n    &lt;script&gt;\n        {% with show_admin_form|default:None as show_form %}\n            {% if show_form is None %}\n                {% define_show_form as show_form %}\n            {% endif %}\n            {% if show_form %}\n                $(document).ready(function() {\n                    $(\".login-box\").insertAfter(\"#login-form\");\n                });\n            {% else %}\n                $(\"#login-form\").remove();\n                $(document).ready(function() {\n                    $(\".login-box\").insertAfter(\".font-semibold.mb-10\");\n                });\n            {% endif %}\n        {% endwith %}\n    &lt;/script&gt;\n{% endblock %}\n</code></pre> <p>And this is the CSS you can use to customize your login button (you will need to create your custom <code>static/django_google_sso/google_button.css/</code> to work):</p> <pre><code>/*\n\n  Please rename this file to google_button.css to override works.\n  This CSS is compatible with Django Unfold CSS\n\n  login-btn\n  ---------------------------------\n  | --------------                 |\n  | | btn-logo   |    btn-label    |\n  | --------------                 |\n  ----------------------------------\n*/\n\n/* Login Button Area */\n.login-btn-area {\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n        width: 382px;\n}\n\n/* Goggle Login Button */\n.google-login-btn {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    background-color: #9233e7;\n    border-radius: 6px;\n    padding: 2px;\n    margin-bottom: 20px;\n    width: 100%;\n    height: 38px;\n    font-family: 'Inter', sans-serif;\n    font-size: 14px;\n    font-weight: 600;\n}\n\n/* Google Login Button Hover */\n.google-login-btn:hover {\n    background-color: #254f89;\n}\n\n/* Google Login Button Remove Decoration */\n.google-login-btn a {\n    text-decoration: none;\n}\n\n/* Google Login Button Logo Area */\n.google-btn-logo {\n    display: flex;\n    justify-content: center;\n    align-content: center;\n    padding: 4px;\n}\n\n\n/* Google Login Button Label Area */\n.google-btn-label {\n    color: #ffffff;\n    margin-top: -1px;\n    width: 100%;\n    text-align: center;\n    padding: 0 10px;\n}\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting/#common-questions","title":"Common questions:","text":"Admin Message: State Mismatched. Time expired? <p>This error occurs when the user is redirected to the Google login page and then returns to the Django login page but original state are not found or session was expired. Please check if the browser has the anonymous session created by Django. This error can occur if you use <code>127.0.0.1</code> instead of <code>localhost</code> for your local tests.</p> Google show the message: The Solicitation from App XXX is Invalid. <p>Make sure you have added the correct Callback URI on Google Console. Please remember the trailing slash for this URI.</p> My custom css is not working <p>Make sure you have added the correct static files path on your <code>settings.py</code> file. Please check the Django documentation for more details. Make sure your path is <code>static/django_google_sso/google_button.css</code>. You can also need to setup the <code>STATICFILES_DIRS</code> setting in your project. Check the Example app below for more details.</p> How can I log out Django user if I log out from Google first? <p>If you log out from Google, the Django user will not be logged out automatically - his user session is valid up to 1 hour, or the time defined, in seconds, in <code>GOOGLE_SSO_SESSION_COOKIE_AGE</code>. You can use the <code>GOOGLE_SSO_SAVE_ACCESS_TOKEN</code> to save the access token generated during user login, and use it to check if the user status in Google (inside a Middleware, for example). Please check the Example App for more details.</p> My callback URL is http://example.com/google_sso/callback/ but my project is running at http://localhost:8000 <p>This error occurs because your Project is using the Django Sites Framework and the current site is not configured correctly. Please make sure that the current site is configured for your needs or, alternatively, use the <code>GOOGLE_SSO_CALLBACK_DOMAIN</code> setting.</p> There's too much information on logs and messages from this app. <p>You can disable the logs using the <code>GOOGLE_SSO_ENABLE_LOGS</code> setting and the messages using the <code>GOOGLE_SSO_ENABLE_MESSAGES</code> setting.</p> System goes looping to admin after login. <p>This is because the user data was received from Google, but the user was not created in the database or is not active. To see these errors please check the logs or enable the option <code>GOOGLE_SSO_SHOW_FAILED_LOGIN_MESSAGE</code> to see failed login messages on browser. Please, make note these messages can be used on exploit attacks.</p> When I config a custom Authentication Backend using GOOGLE_SSO_AUTHENTICATION_BACKEND, the lib stops to login, without errors or logs. <p>This is because the value of <code>GOOGLE_SSO_AUTHENTICATION_BACKEND</code> is not a valid authentication backend import path. Please check the value of this setting and make sure it is a valid import path to a Django authentication backend.</p> When using one package for Admin and another for Pages, the user can enter in Admin, even if I configure the Pages SSO to not give any admin rights <p>Please check if the user is not already a staff or superuser in the database, especially if you're using the <code>MICROSOFT_SSO_UNIQUE_EMAIL</code> and <code>GITHUB_SSO_UNIQUE_EMAIL</code> options. If the user is already a staff or superuser, he will be able to enter in Admin, even if the SSO package for Pages does not give him any admin rights.</p> Got a \"KeyError: 'NAME'\" error after set SSO_USE_ALTERNATE_W003 <p>If you get a <code>KeyError: 'NAME'</code> error, please set a <code>NAME</code> in <code>TEMPLATES</code> at <code>settings.py</code>:</p> <pre><code># settings.py\n\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"NAME\" : \"default\",  # &lt;-- Add name here\n        \"DIRS\": [BASE_DIR / \"templates\"],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n            ],\n        },\n    },\n]\n</code></pre> Got this error when migrating: 'The model User is already registered with 'core.GoogleSSOUserAdmin' <p>This is because you're already define a custom User model and admin in your project. You need to extended the existing user model unregistering your current User Admin class and add manually the GoogleSSOInlineAdmin in your custom class. You can use the <code>get_current_user_and_admin</code> helper as explained here (the recommended action), or alternately, you can add the <code>django-google-sso</code> at the end of your <code>INSTALLED_APPS</code> list.</p>"},{"location":"troubleshooting/#example-app","title":"Example App","text":"<p>To test this library please check the <code>Example App</code> provided here.</p>"},{"location":"troubleshooting/#not-working","title":"Not working?","text":"<p>Don't panic. Get a towel and, please, open an issue.</p>"},{"location":"urls/","title":"Setup Django URLs","text":"<p>The base configuration for Django URLs is the same we have described as before: <pre><code># urls.py\n\nfrom django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"google_sso/\", include(\n            \"django_google_sso.urls\",\n            namespace=\"django_google_sso\"\n        )\n    ),\n]\n</code></pre> You can change the initial Path - <code>google_sso/</code> - to whatever you want - just remember to change it in the Google Console as well.</p>"},{"location":"urls/#overriding-the-login-view-or-path","title":"Overriding the Login view or Path","text":"<p>If you need to override the login view, or just the path, please add on the new view/class the Django SSO Admin login template:</p> <pre><code>from django.contrib.auth.views import LoginView\nfrom django.urls import path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"accounts/login/\",\n        LoginView.as_view(\n            # The modified form with Google button\n            template_name=\"google_sso/login.html\"\n        ),\n    ),\n]\n</code></pre> <p>or you can use a complete custom class:</p> <pre><code>from django.contrib.auth.views import LoginView\n\n\nclass MyLoginView(LoginView):\n    template_name = \"google_sso/login.html\"\n</code></pre>"},{"location":"users/","title":"Auto Creating Users","text":"<p>Django Google SSO can automatically create users from Google SSO authentication. To enable this feature, you need to set the <code>GOOGLE_SSO_ALLOWABLE_DOMAINS</code> setting in your <code>settings.py</code>, with a list of domains that will be allowed to create. For example, if any user with a gmail account can sign in, you can set:</p> <pre><code># settings.py\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"gmail.com\"]\n</code></pre> <p>To allow everyone to register, you can use \"*\" as the value (but beware the security implications):</p> <pre><code># Use \"*\" to add all users\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"*\"]\n</code></pre>"},{"location":"users/#disabling-the-auto-create-users","title":"Disabling the auto-create users","text":"<p>You can disable the auto-create users feature by setting the <code>GOOGLE_SSO_AUTO_CREATE_USERS</code> setting to <code>False</code>:</p> <pre><code>GOOGLE_SSO_AUTO_CREATE_USERS = False\n</code></pre> <p>You can also disable the plugin completely:</p> <pre><code>GOOGLE_SSO_ENABLED = False\n</code></pre>"},{"location":"users/#giving-permissions-to-auto-created-users","title":"Giving Permissions to Auto-Created Users","text":"<p>If you are using the auto-create users feature, you can give permissions to the users that are created automatically. To do this you can set the following options in your <code>settings.py</code>:</p> <pre><code># List of emails that will be created as staff\nGOOGLE_SSO_STAFF_LIST = [\"my-email@my-domain.com\"]\n\n# List of emails that will be created as superuser\nGOOGLE_SSO_SUPERUSER_LIST = [\"another-email@my-domain.com\"]\n\n# If True, the first user that logs in will be created as superuser\n# if no superuser exists in the database at all\nGOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER = True\n</code></pre> <p>For staff user creation only, you can add all users using \"*\" as the value:</p> <pre><code># Use \"*\" to add all users as staff\nGOOGLE_SSO_STAFF_LIST = [\"*\"]\n</code></pre>"},{"location":"users/#fine-tuning-validation-before-user-validation","title":"Fine-tuning validation before user validation","text":"<p>If you need to do some custom validation before user email is validated, you can set the <code>GOOGLE_SSO_PRE_VALIDATE_CALLBACK</code> setting to import a custom function that will be called before the user is created. This function will receive two arguments: the <code>google_user_info</code> dict from Google User API and <code>request</code> objects.</p> <pre><code># myapp/hooks.py\ndef pre_validate_user(google_info, request):\n    # Check some info from google_info and/or request\n    return True  # The user can be created\n</code></pre> <p>Please note, even if this function returns <code>True</code>, the user can be denied if their email is not valid.</p>"},{"location":"users/#fine-tuning-user-info-before-user-creation","title":"Fine-tuning user info before user creation","text":"<p>If you need to do some processing before user is created, you can set the <code>GOOGLE_SSO_PRE_CREATE_CALLBACK</code> setting to import a custom function that will be called before the user is created. This function will receive two arguments: the <code>google_user_info</code> dict from Google User API and <code>request</code> objects.</p> <p>You can add custom fields to the user model here</p> <p>The <code>pre_create_callback</code> function can return a dictionary with the fields and values that will be passed to <code>User.objects.create()</code> as the <code>defaults</code> argument. This means you can add custom fields to the user model here or change default values for some fields, like <code>username</code>.</p> <p>If not defined, the field <code>username</code> is always the user email.</p> <p>You can't change the fields: <code>first_name</code>, <code>last_name</code>, <code>email</code> and <code>password</code> using this callback. These fields are always passed to <code>User.objects.create()</code> with the values from Google API and the password is always unusable.</p> <pre><code>import arrow\n\ndef pre_create_callback(google_info, request) -&gt; dict | None:\n    \"\"\"Callback function called before user is created.\n\n    return: dict content to be passed to\n            User.objects.create() as `defaults` argument.\n            If not informed, field `username` is always\n            the user email.\n    \"\"\"\n\n    user_key = google_info.get(\"email\").split(\"@\")[0]\n    user_id = google_info.get(\"id\")\n\n    return {\n        \"username\": f\"{user_key}_{user_id}\",\n        \"date_joined\": arrow.utcnow().shift(days=-1).datetime,\n    }\n</code></pre>"},{"location":"users/#fine-tuning-users-before-login","title":"Fine-tuning users before login","text":"<p>If you need to do some processing after user is created or retrieved, but before the user is logged in, you can set the <code>GOOGLE_SSO_PRE_LOGIN_CALLBACK</code> setting to import a custom function that will be called before the user is logged in. This function will receive two arguments: the <code>user</code> and <code>request</code> objects.</p> <pre><code># myapp/hooks.py\ndef pre_login_user(user, request):\n    # Do something with the user\n    pass\n\n# settings.py\nGOOGLE_SSO_PRE_LOGIN_CALLBACK = \"myapp.hooks.pre_login_user\"\n</code></pre> <p>Please remember this function will be invoked only if user exists, and if it is active. In other words, if the user is eligible for login.</p> <p>You can add your hooks to customize all steps:</p> <ul> <li><code>GOOGLE_SSO_PRE_VALIDATE_CALLBACK</code>: Run before the user is validated.</li> <li><code>GOOGLE_SSO_PRE_CREATE_CALLBACK</code>: Run before the user is created.</li> <li><code>GOOGLE_SSO_PRE_LOGIN_CALLBACK</code>: Run before the user is logged in.</li> </ul> <p>Be careful with these options</p> <p>The idea here is to make your life easier, especially when testing. But if you are not careful, you can give permissions to users that you don't want, or even worse, you can give permissions to users that you don't know. So, please, be careful with these options.</p> <p>For the last step, we will look at the Django URLs.</p>"}]}